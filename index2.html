[{"id":293,"date":"2023-12-08T15:38:46","date_gmt":"2023-12-08T15:38:46","guid":{"rendered":"https:\/\/blog.podman.io\/?p=293"},"modified":"2023-12-08T15:38:46","modified_gmt":"2023-12-08T15:38:46","slug":"interaction-between-user-namespaces-and-capabilities","status":"publish","type":"post","link":"https:\/\/blog.podman.io\/2023\/12\/interaction-between-user-namespaces-and-capabilities\/","title":{"rendered":"Interaction between User namespaces and Capabilities"},"content":{"rendered":"\n<p>User namespaces and capabilities are important kernel functionality to make containers secure. They allow to better isolate containers and limit the privileges a container might have. A while back a user reported a <a href=\"https:\/\/github.com\/containers\/podman\/issues\/19185\">bug<\/a> where some odd behavior was noticed when namespaces are shared between containers which could lead to security problems. Lets take closer look what can go wrong if you are not aware of the behavior.<\/p>\n\n\n\n<p>First lets build a container image with nftables installed:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ cat Containerfile \nFROM fedora\nRUN dnf install -y nftables\n$ podman build -t testimg .<\/code><\/pre>\n\n\n\n<p><\/p>\n\n\n\n<p>Now we have nft installed in the image and can use it. nft manages the firewall and as such needs the CAP_NET_ADMIN capability to function otherwise it will error. So now when we run <\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ podman run --rm testimg nft list ruleset\nOperation not permitted (you must be root)\nnetlink: Error: cache initialization failed: Operation not permitted\n$ podman run --rm --cap-add CAP_NET_ADMIN testimg nft list ruleset\n&lt;Results omitted for brevity><\/code><\/pre>\n\n\n\n<p>Only the second command works because CAP_NET_ADMIN is not given by default to a container. Note that the command does return any output because there are no rules.<\/p>\n\n\n\n<p>Now assume we run two containers and want to share the network between them, this can be done by using the <code>--network container:&lt;name&gt;<\/code> option. In the first terminal run <\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ podman run --rm --name test -it testimg \n&#91;root@a6a4ddc4a7c8 \/]# nft list ruleset\nOperation not permitted (you must be root)\nnetlink: Error: cache initialization failed: Operation not permitted\n&#91;root@a6a4ddc4a7c8 \/]#<\/code><\/pre>\n\n\n\n<p><\/p>\n\n\n\n<p>In a second terminal run<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ podman run --rm --network container:test -it testimg\n&#91;root@6d4b196e75be \/]# nft list ruleset\nOperation not permitted (you must be root)\nnetlink: Error: cache initialization failed: Operation not permitted<\/code><\/pre>\n\n\n\n<p>In both cases we were not able to modify the namespace as expected.<\/p>\n\n\n\n<p>Lets run the commands again but this time we use <code>--userns keep-id<\/code> for the first container.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code># terminal 1\n$ podman run --rm --name test --userns keep-id --user 0:0 -it testimg \n&#91;root@91896ef2fac8 \/]# nft list ruleset\nOperation not permitted (you must be root)\nnetlink: Error: cache initialization failed: Operation not permitted\n&#91;root@91896ef2fac8 \/]#\n\n# terminal 2\n podman run --rm --network container:test -it testimg\n&#91;root@59ad31cb4de1 \/]# nft list ruleset\n&#91;root@59ad31cb4de1 \/]#<\/code><\/pre>\n\n\n\n<p>Now even though we did not give the second container CAP_NET_ADMIN it can still modify the network. This is unexpected for most people and can thus creating a security problem if you do something like this and are not aware of it.<\/p>\n\n\n\n<p>Now lets do it one last time but use <code>--userns keep-id<\/code> for the second container.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code># terminal 1\n$ podman run --rm --name test -it testimg \n&#91;root@8860d6004a8d \/]# nft list ruleset\nOperation not permitted (you must be root)\nnetlink: Error: cache initialization failed: Operation not permitted\n&#91;root@8860d6004a8d \/]# \n\n# terminal 2\n$ podman run --rm --network container:test --userns keep-id --user 0:0 -it testimg\n&#91;root@10cb690d5b93 \/]# nft list ruleset\nOperation not permitted (you must be root)\nnetlink: Error: cache initialization failed: Operation not permitted\n&#91;root@10cb690d5b93 \/]#<\/code><\/pre>\n\n\n\n<p>Now again neither container can modify the network. You can even add <code>--cap-add CAP_NET_ADMIN<\/code> to the second container and it will still not work.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\">What is happening?<\/h2>\n\n\n\n<p>The behavior may seems unexpected and broken at first but this works exactly as designed by the kernel security checks. Capabilities are always per user namespace, when a new user namespace is created the process will get all capabilities in the new namespace but drops all in the parent namespace. It is also important to know that the kernel checks the permissions of namespaces always based from which user namespace the other namespace was created. If the namespace was created from any parent user namespace then the kernel will not allow you to modify it, you basically have no capabilities for them. On the other side for namespaces created by child user namespaces it will always have all capabilities even if a process drop them.<\/p>\n\n\n\n<p>This is exactly what was happening in the second case. The OCI runtime first creates the child user namespace then within it it created a new network namespace. The second container then is in the parent user namespace so it will always have all capabilities for the shared network namespace.<\/p>\n\n\n\n<figure class=\"wp-block-image size-full is-resized\"><img loading=\"lazy\" decoding=\"async\" width=\"281\" height=\"131\" src=\"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/12\/userns-caps-1.png?resize=281%2C131&#038;ssl=1\" alt=\"\" class=\"wp-image-295\" style=\"aspect-ratio:2.145038167938931;width:431px;height:auto\" data-recalc-dims=\"1\"\/><\/figure>\n\n\n\n<p> In the third case it is the other way around the second container is part of the user namespace and thus the child, therefore it can never modify  the network namespace which was created by the parent user namespace.<\/p>\n\n\n\n<figure class=\"wp-block-image size-full is-resized\"><img loading=\"lazy\" decoding=\"async\" width=\"281\" height=\"131\" src=\"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/12\/userns-caps-2.png?resize=281%2C131&#038;ssl=1\" alt=\"\" class=\"wp-image-296\" style=\"aspect-ratio:2.145038167938931;width:431px;height:auto\" data-recalc-dims=\"1\"\/><\/figure>\n\n\n\n<p>To fix this issue it is best to also share the user namespace between the containers, as long as both containers are part of the same user namespace you get your expected behavior were the given capabilities are respected. Lets try the second case again but this time with<code> --userns container:<\/code> for the second container as well.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code># terminal 1\n$ podman run --rm --name test --userns keep-id --user 0:0 -it testimg \n&#91;root@198c6101c2cd \/]# nft list ruleset\nOperation not permitted (you must be root)\nnetlink: Error: cache initialization failed: Operation not permitted\n&#91;root@198c6101c2cd \/]#\n\n# terminal 2\n$ podman run --rm --network container:test --userns container:test  -it testimg\n&#91;root@43644d997e2d \/]# nft list ruleset\nOperation not permitted (you must be root)\nnetlink: Error: cache initialization failed: Operation not permitted\n&#91;root@43644d997e2d \/]# <\/code><\/pre>\n\n\n\n<figure class=\"wp-block-image size-full is-resized\"><img loading=\"lazy\" decoding=\"async\" width=\"281\" height=\"131\" src=\"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/12\/userns-caps-3.png?resize=281%2C131&#038;ssl=1\" alt=\"\" class=\"wp-image-297\" style=\"aspect-ratio:2.145038167938931;width:438px;height:auto\" data-recalc-dims=\"1\"\/><\/figure>\n\n\n\n<p>The network namespace was just one example the rule applies to the other namespaces as well. You can read more about the behavior in the man page <a href=\"https:\/\/man7.org\/linux\/man-pages\/man7\/user_namespaces.7.html\">user_namespaces(7)<\/a>.  With this knowledge you can avoid accidentally giving your containers more privileges than they should have.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>User namespaces and capabilities are important kernel functionality to make containers secure. They allow to better isolate containers and limit the privileges a container might have. A while back a user reported a bug where some odd behavior was noticed when namespaces are shared between containers which could lead to security problems. Lets take closer [&hellip;]<\/p>\n","protected":false},"author":13,"featured_media":259,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"jetpack_post_was_ever_published":false,"_jetpack_newsletter_access":"","_jetpack_dont_email_post_to_subs":false,"_jetpack_newsletter_tier_id":0,"footnotes":"","jetpack_publicize_message":"","jetpack_publicize_feature_enabled":true,"jetpack_social_post_already_shared":true,"jetpack_social_options":{"image_generator_settings":{"template":"highway","enabled":false}}},"categories":[18,23,25],"tags":[12,10],"jetpack_publicize_connections":[],"jetpack_sharing_enabled":true,"featured_image_src":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/09\/image.png?resize=600%2C400&ssl=1","featured_image_src_square":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/09\/image.png?resize=600%2C600&ssl=1","author_info":{"display_name":"Paul Holzinger","author_link":"https:\/\/blog.podman.io\/author\/pholzing\/"},"jetpack_featured_media_url":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/09\/image.png?fit=1920%2C1080&ssl=1","jetpack-related-posts":[],"_links":{"self":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts\/293"}],"collection":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/users\/13"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/comments?post=293"}],"version-history":[{"count":0,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts\/293\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/media\/259"}],"wp:attachment":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/media?parent=293"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/categories?post=293"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/tags?post=293"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}},{"id":291,"date":"2023-11-27T20:02:13","date_gmt":"2023-11-27T20:02:13","guid":{"rendered":"https:\/\/blog.podman.io\/?p=291"},"modified":"2023-11-27T20:02:13","modified_gmt":"2023-11-27T20:02:13","slug":"podman-v4-8-released","status":"publish","type":"post","link":"https:\/\/blog.podman.io\/2023\/11\/podman-v4-8-released\/","title":{"rendered":"Podman v4.8 released!"},"content":{"rendered":"\n<p>We\u2019re excited to announce that Podman v4.8.0 has been released! This release includes over 20 features and over 20 bugfixes each. Some highlights include:<\/p>\n\n\n\n<ul>\n<li><strong><mark style=\"background-color:#fcf9ff;color:#000000\" class=\"has-inline-color\">HyperV Support<\/mark><\/strong>: Podman machine now supports HyperV as a provider on Windows.<\/li>\n\n\n\n<li><mark style=\"background-color:#fcf9ff;color:#000000\" class=\"has-inline-color\"><strong>Heredoc Support<\/strong>:<\/mark> Containerfiles that contain heredoc syntax can now be built using <code>podman build<\/code>.\u00a0<\/li>\n\n\n\n<li><mark style=\"background-color:#fcf9ff;color:#000000\" class=\"has-inline-color\"><strong>SQLite <\/strong>:<\/mark> Podman now defaults to SQLite as its database backend. But don&#8217;t worry! If you are still currently using BoltDB, podman will continue to use Bolt, unless you choose to manually use SQLite<\/li>\n<\/ul>\n\n\n\n<p><\/p>\n\n\n\n<p>For a full list of changes, see our <a href=\"https:\/\/github.com\/containers\/podman\/releases\/tag\/v4.6.0\"><\/a><a href=\"https:\/\/github.com\/containers\/podman\/releases\/tag\/v4.8.0\">GitHub release<\/a> page. Big thanks to our contributors and community! Try it out and let us know what you think!<\/p>\n\n\n\n<p><mark style=\"background-color:#fcf9ff;color:#000000\" class=\"has-inline-color\">Upcoming Deprecation Notices:<\/mark> We are beginning development on Podman 5.0, which will include a bunch of new features, but also a number of breaking changes and deprecations. We are still finalizing what will be done, but a preliminary list is below. Please note that none of these changes are present in Podman 4.8; this is a preview of upcoming changes.<\/p>\n\n\n\n<ul>\n<li>Podman 5.0 will deprecate the BoltDB database backend. Exact details on the transition to SQLite are still being decided &#8211; expect more news here soon.<\/li>\n\n\n\n<li>The containers.conf configuration file will be broken up into multiple separate files, ensuring that it will never be rewritten by Podman.<\/li>\n\n\n\n<li>Support for the CNI network backend and Cgroups V1 are being deprecated and gated by build tags. They will not be enabled in Podman builds by default.<\/li>\n\n\n\n<li>A variety of small breaking changes to the REST API are planned, both to improve Docker compatibility and to better support containers.conf settings when creating and managing containers.<\/li>\n<\/ul>\n\n\n\n<p><\/p>\n","protected":false},"excerpt":{"rendered":"<p>We\u2019re excited to announce that Podman v4.8.0 has been released! This release includes over 20 features and over 20 bugfixes each. Some highlights include: For a full list of changes, see our GitHub release page. Big thanks to our contributors and community! Try it out and let us know what you think! Upcoming Deprecation Notices: [&hellip;]<\/p>\n","protected":false},"author":11,"featured_media":218,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"jetpack_post_was_ever_published":false,"_jetpack_newsletter_access":"","_jetpack_dont_email_post_to_subs":false,"_jetpack_newsletter_tier_id":0,"footnotes":"","jetpack_publicize_message":"","jetpack_publicize_feature_enabled":true,"jetpack_social_post_already_shared":true,"jetpack_social_options":{"image_generator_settings":{"template":"highway","enabled":false}}},"categories":[20,23,25,13],"tags":[36,10],"jetpack_publicize_connections":[],"jetpack_sharing_enabled":true,"featured_image_src":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/07\/podman_blog-banner.png?resize=600%2C400&ssl=1","featured_image_src_square":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/07\/podman_blog-banner.png?resize=600%2C480&ssl=1","author_info":{"display_name":"Ashley Cui","author_link":"https:\/\/blog.podman.io\/author\/acui\/"},"jetpack_featured_media_url":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2023\/07\/podman_blog-banner.png?fit=960%2C480&ssl=1","jetpack-related-posts":[],"_links":{"self":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts\/291"}],"collection":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/users\/11"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/comments?post=291"}],"version-history":[{"count":0,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts\/291\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/media\/218"}],"wp:attachment":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/media?parent=291"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/categories?post=291"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/tags?post=291"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}},{"id":280,"date":"2023-11-27T14:27:51","date_gmt":"2023-11-27T14:27:51","guid":{"rendered":"https:\/\/blog.podman.io\/?p=280"},"modified":"2023-11-27T14:48:08","modified_gmt":"2023-11-27T14:48:08","slug":"new-netavark-firewalld-reload-service","status":"publish","type":"post","link":"https:\/\/blog.podman.io\/2023\/11\/new-netavark-firewalld-reload-service\/","title":{"rendered":"New Netavark firewalld reload service"},"content":{"rendered":"\n<p>One longstanding problem with  Podman is that your rootful containers may loose network connectivity after a while. For many users it is not be obvious what is causing such problems. Netavark configures NAT and port forwarding firewall rules. When another process is deleting our firewall rules the containers will loose connectivity. One such process is firewalld, when firewall-cmd &#8211;reload is executed it will delete all firewall rules and then only add rules known to firewalld back leaving podman containers without connection. The interesting part here is that this command may not even have to be executed by users. Some applications run this command on update, for example it is possible that <code>dnf update<\/code> results in firewalld being reloaded making it harder for users to know what happened. NOTE: Starting with firewalld 2.0 it may no longer flushes all rules and only the firewalld specific ones.<\/p>\n\n\n\n<p>One solution to restore the rules is to simply restart the containers as all the necessary rules will be added on container start. However this is undesirable as some container application may need a long time to stop and\/or start. To address this issue Podman added the <code>podman network reload<\/code> command a long time ago. This command removes and then adds the network configuration back. It worked recently well but there is still one big problem with it: The command needs to be explicitly executed after the rules are lost. Therefore it will not help users that are not aware when rules are lost.<\/p>\n\n\n\n<p>With netavark v1.9.0 we added a new systemd service called <code>netavark-firewalld-reload.service<\/code> which should fix the problem once and for all. This service runs a small netavark command which listens on dbus for the firewalld reload event. This event is emitted every time firewalld was reloaded and flushed out the netavark firewall rules. If the event is received the service will then add back all the netavark firewall rules.<\/p>\n\n\n\n<p>The new systemd service is designed in such a way that it only runs when firewalld itself is also running to not consume resources unless needed. The following shows an example on how to enable the service.<\/p>\n\n\n\n<p>First we enable the service, notice that enable does not necessarily mean start on boot. For our unit we add a wants to firewalld which means the service is only started when firewalld is started. This ensures that on systems were firewalld is not used or disabled it won&#8217;t run unnecessarily. The service will also stop when firewalld is stopped.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ sudo systemctl enable netavark-firewalld-reload.service\nCreated symlink \/etc\/systemd\/system\/firewalld.service.wants\/netavark-firewalld-reload.service \u2192 \/usr\/lib\/systemd\/system\/netavark-firewalld-reload.service.<\/code><\/pre>\n\n\n\n<p><\/p>\n\n\n\n<p>Now restart firewalld to see that our service will get started with it as well. Alternatively  directly start our service or reboot assuming firewalld is enabled. <\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ sudo systemctl restart firewalld.service\n$ sudo systemctl status netavark-firewalld-reload.service \n\u25cf netavark-firewalld-reload.service - Listen for the firewalld reload event and reapply all netavark firewall rules.\n     Loaded: loaded (\/usr\/lib\/systemd\/system\/netavark-firewalld-reload.service; enabled; preset: disabled)\n    Drop-In: \/usr\/lib\/systemd\/system\/service.d\n             \u2514\u250010-timeout-abort.conf\n     Active: active (running) since Mon 2023-11-13 18:00:17 CET; 22s ago\n   Main PID: 72763 (netavark)\n      Tasks: 3 (limit: 38149)\n     Memory: 15.4M\n        CPU: 9ms\n     CGroup: \/system.slice\/netavark-firewalld-reload.service\n             \u2514\u250072763 \/usr\/libexec\/podman\/netavark firewalld-reload\n\nNov 13 18:00:17 pholzing-fedora systemd&#91;1]: Started netavark-firewalld-reload.service - Listen for the firewalld reload event and reapply all netavark firewall rules..<\/code><\/pre>\n\n\n\n<p><\/p>\n\n\n\n<p>Lets start a simple webserver and see if it works.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ sudo podman run -dt -p 8080:80 docker.io\/library\/nginx\n52f2c11810d78f69287874e2469d4caec99176b583e378732cee4623cbd09476\n$ curl -s 127.0.0.1:8080 | head -n4\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;\/title&gt;\n$ sudo firewall-cmd --reload \nsuccess\n$ curl -s 127.0.0.1:8080 | head -n4\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;\/title&gt;<\/code><\/pre>\n\n\n\n<p>Without the service the curl command after the firewalld reload command would just hang. This shows that the netavark-firewalld-reload.service is actually working as expected.<\/p>\n\n\n\n<p>Notice that this is a netavark specific feature and if you are still using the old CNI backend it will not work.<br>Try the new service and let us know if you encounter any problems with it report issues on <a href=\"https:\/\/github.com\/containers\/netavark\/issues\" data-type=\"link\" data-id=\"https:\/\/github.com\/containers\/netavark\/issues\">the netavark github repo<\/a>. <\/p>\n","protected":false},"excerpt":{"rendered":"<p>One longstanding problem with Podman is that your rootful containers may loose network connectivity after a while. For many users it is not be obvious what is causing such problems. Netavark configures NAT and port forwarding firewall rules. When another process is deleting our firewall rules the containers will loose connectivity. One such process is [&hellip;]<\/p>\n","protected":false},"author":13,"featured_media":140,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"jetpack_post_was_ever_published":false,"_jetpack_newsletter_access":"","_jetpack_dont_email_post_to_subs":false,"_jetpack_newsletter_tier_id":0,"footnotes":"","jetpack_publicize_message":"","jetpack_publicize_feature_enabled":true,"jetpack_social_post_already_shared":true,"jetpack_social_options":{"image_generator_settings":{"template":"highway","enabled":false}}},"categories":[18,23,25],"tags":[15,14,10],"jetpack_publicize_connections":[],"jetpack_sharing_enabled":true,"featured_image_src":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2022\/12\/container-2879154_1920.jpg?resize=600%2C400&ssl=1","featured_image_src_square":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2022\/12\/container-2879154_1920.jpg?resize=600%2C600&ssl=1","author_info":{"display_name":"Paul Holzinger","author_link":"https:\/\/blog.podman.io\/author\/pholzing\/"},"jetpack_featured_media_url":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2022\/12\/container-2879154_1920.jpg?fit=1920%2C1194&ssl=1","jetpack-related-posts":[],"_links":{"self":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts\/280"}],"collection":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/users\/13"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/comments?post=280"}],"version-history":[{"count":0,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts\/280\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/media\/140"}],"wp:attachment":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/media?parent=280"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/categories?post=280"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/tags?post=280"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}},{"id":285,"date":"2023-11-22T13:56:06","date_gmt":"2023-11-22T13:56:06","guid":{"rendered":"https:\/\/blog.podman.io\/?p=285"},"modified":"2023-11-22T13:56:06","modified_gmt":"2023-11-22T13:56:06","slug":"podmans-main-branch-is-now-5-0-0-dev","status":"publish","type":"post","link":"https:\/\/blog.podman.io\/2023\/11\/podmans-main-branch-is-now-5-0-0-dev\/","title":{"rendered":"Podman&#8217;s main branch is now 5.0.0-dev"},"content":{"rendered":"\n<p>We recently branched Podman 4.8 for a soon to be release.  But the big news is our <a href=\"https:\/\/github.com\/containers\/podman\">main branch <\/a>is now 5.0.0-dev.  For our users, this means a new major version of Podman has begun its genesis.<\/p>\n\n\n\n<h2 class=\"wp-block-heading\">What can users expect?<\/h2>\n\n\n\n<p>We plan to begin releases of Podman 5.0.0  in early 2024.  At this point, Podman 5 will focus largely on:<\/p>\n\n\n\n<ul>\n<li> stabilizing and simplifying Podman machine<\/li>\n\n\n\n<li>deprecating old technologies,<\/li>\n\n\n\n<li>switching new technologies to the default<\/li>\n\n\n\n<li>improving how Podman deals with its configuration files<\/li>\n<\/ul>\n\n\n\n<h2 class=\"wp-block-heading\">What about the 4.x branch?<\/h2>\n\n\n\n<p>We do intend to release bug fixes on 4.8 as needed and also have a 4.9 planned at about the same time at 5.0 is released.  As far as which release will be in what distribution, we leave that to our partners.  For Fedora, we do anticipate that some version of Podman 5 will be shipped in Fedora 41.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>We recently branched Podman 4.8 for a soon to be release. But the big news is our main branch is now 5.0.0-dev. For our users, this means a new major version of Podman has begun its genesis. What can users expect? We plan to begin releases of Podman 5.0.0 in early 2024. At this point, [&hellip;]<\/p>\n","protected":false},"author":2,"featured_media":139,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"jetpack_post_was_ever_published":false,"_jetpack_newsletter_access":"","_jetpack_dont_email_post_to_subs":false,"_jetpack_newsletter_tier_id":0,"footnotes":"","jetpack_publicize_message":"","jetpack_publicize_feature_enabled":true,"jetpack_social_post_already_shared":true,"jetpack_social_options":{"image_generator_settings":{"template":"highway","enabled":false}}},"categories":[23,25],"tags":[10,9,17],"jetpack_publicize_connections":[],"jetpack_sharing_enabled":true,"featured_image_src":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2022\/12\/pexels-kevin-ku-577585.jpg?resize=600%2C400&ssl=1","featured_image_src_square":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2022\/12\/pexels-kevin-ku-577585.jpg?resize=600%2C600&ssl=1","author_info":{"display_name":"Brent Baude","author_link":"https:\/\/blog.podman.io\/author\/bbaude\/"},"jetpack_featured_media_url":"https:\/\/i0.wp.com\/blog.podman.io\/wp-content\/uploads\/2022\/12\/pexels-kevin-ku-577585.jpg?fit=1920%2C1440&ssl=1","jetpack-related-posts":[],"_links":{"self":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts\/285"}],"collection":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/comments?post=285"}],"version-history":[{"count":0,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/posts\/285\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/media\/139"}],"wp:attachment":[{"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/media?parent=285"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/categories?post=285"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/blog.podman.io\/wp-json\/wp\/v2\/tags?post=285"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}]